{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-aa6032fba70dc906d712651039d5c64b887ce245",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/WorkHistory.sol": "project/contracts/WorkHistory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/WorkHistory.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity ^0.8.28;\r\n\r\ncontract WorkHistory {\r\n    address public owner;\r\n    address public fluenceBackendAddress = 0xDCeFdee35A355715924C100870a5689b06c2dd95;\r\n    uint256 public VERIFICATION_THRESHOLD = 3; // Need 3 verifications to trust\r\n    \r\n    modifier onlyFluenceBackend() {\r\n        require(msg.sender == fluenceBackendAddress, \"Only Fluence Backend\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Only owner\");\r\n        _;\r\n    }\r\n\r\n    struct VerificationStatus {\r\n        mapping(address => bool) companyToValidOrNot; // Tracks which companies have verified\r\n        uint256 count; // Number of verifications received\r\n    }\r\n\r\n    struct Organization {\r\n        string orgName;\r\n        string orgWebsite;\r\n        string physicalAddress; // Renamed for clarity\r\n        address orgWalletAddress;\r\n        bool isTrusted;\r\n        bool isFromConstructor;\r\n    }\r\n\r\n    address[] public pendingOrgs;\r\n    \r\n    Organization[] public initialOrganizations;\r\n\r\n    mapping(address => Organization) public organizations;\r\n    mapping(address => VerificationStatus) public verificationStatuses;\r\n\r\n    struct DocumentRecord {\r\n        bytes32 documentHash; // Hash of the document (e.g., IPFS hash)\r\n        address addedBy; // Address of the organization that added the document\r\n        uint256 timestamp; // Timestamp when the document was added\r\n    }\r\n\r\n    // Store the documents added by orgs only\r\n    mapping(address => DocumentRecord[]) private userDocuments;\r\n    mapping(address => bool) public registeredEmployees;\r\n    address[] public registeredEmployeesList; // Array to track all registered employees\r\n\r\n    struct ConstructorArgumentsOrganizations {\r\n        string orgName;\r\n        string orgWebsite;\r\n        string physicalAddress;\r\n        address orgWalletAddress;\r\n    }\r\n\r\n    event OrganizationAdded(address indexed orgAddress, string orgName);\r\n    event OrganizationVerified(address indexed orgAddress, address verifiedBy);\r\n    event OrganizationTrusted(address indexed orgAddress);\r\n    event DocumentAdded(address indexed user, address indexed addedBy, bytes32 documentHash);\r\n    event EmployeeRegistered(address indexed employee);\r\n\r\n    constructor(ConstructorArgumentsOrganizations[] memory _orgs, address _fluenceBackendAddress){\r\n        \r\n        fluenceBackendAddress = _fluenceBackendAddress;\r\n        \r\n        for (uint256 i = 0; i < _orgs.length; i++) {\r\n            organizations[_orgs[i].orgWalletAddress] = Organization({\r\n                orgName: _orgs[i].orgName,\r\n                orgWebsite: _orgs[i].orgWebsite,\r\n                physicalAddress: _orgs[i].physicalAddress,\r\n                orgWalletAddress: _orgs[i].orgWalletAddress,\r\n                isTrusted: true,\r\n                isFromConstructor: true\r\n            });\r\n\r\n            initialOrganizations.push(organizations[_orgs[i].orgWalletAddress]);\r\n            \r\n            emit OrganizationAdded(_orgs[i].orgWalletAddress, _orgs[i].orgName);\r\n            emit OrganizationTrusted(_orgs[i].orgWalletAddress);\r\n        }\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function getAllInitialOrganizationIds() public view returns (Organization[] memory) {\r\n        return initialOrganizations;\r\n    }\r\n\r\n\r\n    function addOrganization(ConstructorArgumentsOrganizations memory _org) public {\r\n        require(\r\n            msg.sender == owner || organizations[msg.sender].isTrusted, \r\n            \"Not authorized\"\r\n        );\r\n        require(\r\n            organizations[_org.orgWalletAddress].orgWalletAddress == address(0), \r\n            \"Organization already exists\"\r\n        );\r\n\r\n        organizations[_org.orgWalletAddress] = Organization({\r\n            orgName: _org.orgName,\r\n            orgWebsite: _org.orgWebsite,\r\n            physicalAddress: _org.physicalAddress,\r\n            orgWalletAddress: _org.orgWalletAddress,\r\n            isTrusted: false,\r\n            isFromConstructor: false\r\n        });\r\n\r\n        pendingOrgs.push(_org.orgWalletAddress);\r\n        emit OrganizationAdded(_org.orgWalletAddress, _org.orgName);\r\n    }\r\n\r\n    function verifyOrganization(address _orgAddress) public {\r\n        require(organizations[msg.sender].isTrusted, \"Only trusted organizations can verify\");\r\n        require(!organizations[_orgAddress].isTrusted, \"Organization already trusted\");\r\n        require(organizations[_orgAddress].orgWalletAddress != address(0), \"Organization does not exist\");\r\n        require(!verificationStatuses[_orgAddress].companyToValidOrNot[msg.sender], \"Already verified by this organization\");\r\n\r\n        verificationStatuses[_orgAddress].companyToValidOrNot[msg.sender] = true;\r\n        verificationStatuses[_orgAddress].count++;\r\n\r\n        emit OrganizationVerified(_orgAddress, msg.sender);\r\n\r\n        // Check if verification threshold is met\r\n        if (verificationStatuses[_orgAddress].count >= VERIFICATION_THRESHOLD) {\r\n            organizations[_orgAddress].isTrusted = true;\r\n            emit OrganizationTrusted(_orgAddress);\r\n            \r\n            // Remove from pending\r\n            _removePendingOrg(_orgAddress);\r\n        }\r\n    }\r\n\r\n    function verifyOrganizationOnBehalf(address _voter, address _orgAddress) public onlyFluenceBackend {\r\n        require(organizations[_voter].isTrusted, \"Voter organization must be trusted\");\r\n        require(!organizations[_orgAddress].isTrusted, \"Organization already trusted\");\r\n        require(organizations[_orgAddress].orgWalletAddress != address(0), \"Organization does not exist\");\r\n        require(!verificationStatuses[_orgAddress].companyToValidOrNot[_voter], \"Already verified by this organization\");\r\n\r\n        verificationStatuses[_orgAddress].companyToValidOrNot[_voter] = true;\r\n        verificationStatuses[_orgAddress].count++;\r\n\r\n        emit OrganizationVerified(_orgAddress, _voter);\r\n\r\n        // Check if verification threshold is met\r\n        if (verificationStatuses[_orgAddress].count >= VERIFICATION_THRESHOLD) {\r\n            organizations[_orgAddress].isTrusted = true;\r\n            emit OrganizationTrusted(_orgAddress);\r\n            \r\n            // Remove from pending\r\n            _removePendingOrg(_orgAddress);\r\n        }\r\n    }\r\n\r\n    function registerEmployee(address _employee) public onlyFluenceBackend{\r\n        if (!registeredEmployees[_employee]) {\r\n            registeredEmployees[_employee] = true;\r\n            registeredEmployeesList.push(_employee);\r\n        }\r\n        emit EmployeeRegistered(_employee);\r\n    }\r\n\r\n    function getUserDocuments(address _user) public view returns (DocumentRecord[] memory) {\r\n        return userDocuments[_user];\r\n    }\r\n\r\n    function addDocument(address _user, bytes32 _documentHash) public {\r\n        require(organizations[msg.sender].isTrusted, \"Only trusted organizations can add documents\");\r\n        require(registeredEmployees[_user], \"Employee not registered\");\r\n\r\n        userDocuments[_user].push(DocumentRecord({\r\n            documentHash: _documentHash,\r\n            addedBy: msg.sender,\r\n            timestamp: block.timestamp\r\n        }));\r\n\r\n        emit DocumentAdded(_user, msg.sender, _documentHash);\r\n    }\r\n\r\n    function getPendingOrganizations() public view returns (address[] memory) {\r\n        return pendingOrgs;\r\n    }\r\n\r\n    function getVerificationCount(address _orgAddress) public view returns (uint256) {\r\n        return verificationStatuses[_orgAddress].count;\r\n    }\r\n\r\n    function hasVerified(address _orgAddress, address _verifier) public view returns (bool) {\r\n        return verificationStatuses[_orgAddress].companyToValidOrNot[_verifier];\r\n    }\r\n\r\n    function _removePendingOrg(address _orgAddress) private {\r\n        for (uint256 i = 0; i < pendingOrgs.length; i++) {\r\n            if (pendingOrgs[i] == _orgAddress) {\r\n                pendingOrgs[i] = pendingOrgs[pendingOrgs.length - 1];\r\n                pendingOrgs.pop();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    struct UserData {\r\n        DocumentRecord[] documents;\r\n        Organization[] organizationsThatAdded;\r\n    }\r\n\r\n    function getUsersData(address _user) public view returns (UserData[] memory, bool) {\r\n        // check if user is registered\r\n        if(!registeredEmployees[_user]){\r\n            return (new UserData[](0), false);\r\n        }\r\n\r\n        DocumentRecord[] memory docs = userDocuments[_user];\r\n        UserData[] memory data = new UserData[](docs.length);\r\n        for (uint256 i = 0; i < docs.length; i++) {\r\n            data[i].documents = new DocumentRecord[](1);\r\n            data[i].documents[0] = docs[i];\r\n            data[i].organizationsThatAdded = new Organization[](1);\r\n            data[i].organizationsThatAdded[0] = organizations[docs[i].addedBy];\r\n        }\r\n        return (data, true);\r\n    }\r\n\r\n    function getOrganizationsPastAddedDocuments(address _orgAddress) public view returns (\r\n        DocumentRecord[] memory orgDocuments,\r\n        address[] memory correspondingUsers\r\n    ) {\r\n        require(organizations[_orgAddress].orgWalletAddress != address(0), \"Organization does not exist\");\r\n        \r\n        // First pass: count total documents added by this organization\r\n        uint256 totalCount = 0;\r\n        for (uint256 i = 0; i < registeredEmployeesList.length; i++) {\r\n            address user = registeredEmployeesList[i];\r\n            DocumentRecord[] memory userDocs = userDocuments[user];\r\n            for (uint256 j = 0; j < userDocs.length; j++) {\r\n                if (userDocs[j].addedBy == _orgAddress) {\r\n                    totalCount++;\r\n                }\r\n            }\r\n        }\r\n        \r\n        // Initialize arrays with the correct size\r\n        orgDocuments = new DocumentRecord[](totalCount);\r\n        correspondingUsers = new address[](totalCount);\r\n        \r\n        // Second pass: populate the arrays\r\n        uint256 currentIndex = 0;\r\n        for (uint256 i = 0; i < registeredEmployeesList.length; i++) {\r\n            address user = registeredEmployeesList[i];\r\n            DocumentRecord[] memory userDocs = userDocuments[user];\r\n            for (uint256 j = 0; j < userDocs.length; j++) {\r\n                if (userDocs[j].addedBy == _orgAddress) {\r\n                    orgDocuments[currentIndex] = userDocs[j];\r\n                    correspondingUsers[currentIndex] = user;\r\n                    currentIndex++;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return (orgDocuments, correspondingUsers);\r\n    }\r\n\r\n    function checkIfEmployeeExists(address _employee) public view returns (bool) {\r\n        return registeredEmployees[_employee];\r\n    }\r\n\r\n    function checkIfOrgExists(address _orgAddress) public view returns (bool) {\r\n        return organizations[_orgAddress].orgWalletAddress != address(0);\r\n    }\r\n\r\n    // Emergency functions for owner\r\n    function removeOrganization(address _orgAddress) public onlyOwner {\r\n        require(!organizations[_orgAddress].isFromConstructor, \"Cannot remove constructor organizations\");\r\n        delete organizations[_orgAddress];\r\n        _removePendingOrg(_orgAddress);\r\n    }\r\n\r\n    function setVerificationThreshold(uint256 _newThreshold) public onlyOwner {\r\n        // Note: This would require updating the constant to a state variable\r\n        // VERIFICATION_THRESHOLD = _newThreshold;\r\n    }\r\n\r\n    function addToInitialOrganizations(ConstructorArgumentsOrganizations memory _org) public onlyOwner {\r\n        require(\r\n            organizations[_org.orgWalletAddress].orgWalletAddress == address(0), \r\n            \"Organization already exists\"\r\n        );\r\n\r\n        organizations[_org.orgWalletAddress] = Organization({\r\n            orgName: _org.orgName,\r\n            orgWebsite: _org.orgWebsite,\r\n            physicalAddress: _org.physicalAddress,\r\n            orgWalletAddress: _org.orgWalletAddress,\r\n            isTrusted: true,\r\n            isFromConstructor: true\r\n        });\r\n\r\n        initialOrganizations.push(organizations[_org.orgWalletAddress]);\r\n        \r\n        emit OrganizationAdded(_org.orgWalletAddress, _org.orgName);\r\n        emit OrganizationTrusted(_org.orgWalletAddress);\r\n    }\r\n\r\n    event InitialOrganizationRemoved(address indexed orgAddress);\r\n\r\n    function removeInitialOrganization(address _orgAddress) public onlyOwner {\r\n        require(organizations[_orgAddress].isFromConstructor, \"Only constructor organizations can be removed here\");\r\n        delete organizations[_orgAddress];\r\n\r\n        // Remove from initialOrganizations array\r\n        for (uint256 i = 0; i < initialOrganizations.length; i++) {\r\n            if (initialOrganizations[i].orgWalletAddress == _orgAddress) {\r\n                initialOrganizations[i] = initialOrganizations[initialOrganizations.length - 1];\r\n                initialOrganizations.pop();\r\n                break;\r\n            }\r\n        }\r\n\r\n        emit InitialOrganizationRemoved(_orgAddress);\r\n    }\r\n    \r\n}"
      }
    }
  }
}