{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-fdd6c5f7861d238690f95b40ab7986b07ec759e1",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/WorkHistory.sol": "project/contracts/WorkHistory.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/WorkHistory.sol": {
        "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.28;\n\ncontract WorkHistory {\n    address public owner;\n    address public fluenceBackendAddress = 0xDCeFdee35A355715924C100870a5689b06c2dd95;\n    uint256 public constant VERIFICATION_THRESHOLD = 3; // Need 3 verifications to trust\n    \n    modifier onlyFluenceBackend() {\n        require(msg.sender == fluenceBackendAddress, \"Only Fluence Backend\");\n        _;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner\");\n        _;\n    }\n\n    struct VerificationStatus {\n        mapping(address => bool) companyToValidOrNot;\n        uint256 count; // Number of verifications received\n    }\n\n    struct Organization {\n        string orgName;\n        string orgWebsite;\n        string physicalAddress; // Renamed for clarity\n        address orgWalletAddress;\n        bool isTrusted;\n        bool isFromConstructor;\n    }\n\n    address[] public pendingOrgs;\n    mapping(address => Organization) public organizations;\n    mapping(address => VerificationStatus) public verificationStatuses;\n\n    struct DocumentRecord {\n        bytes32 documentHash; // Hash of the document (e.g., IPFS hash)\n        address addedBy; // Address of the organization that added the document\n        uint256 timestamp; // Timestamp when the document was added\n    }\n\n    // Store the documents added by orgs only\n    mapping(address => DocumentRecord[]) private userDocuments;\n    mapping(address => bool) public registeredEmployees;\n\n    struct ConstructorArgumentsOrganizations {\n        string orgName;\n        string orgWebsite;\n        string physicalAddress;\n        address orgWalletAddress;\n    }\n\n    event OrganizationAdded(address indexed orgAddress, string orgName);\n    event OrganizationVerified(address indexed orgAddress, address verifiedBy);\n    event OrganizationTrusted(address indexed orgAddress);\n    event DocumentAdded(address indexed user, address indexed addedBy, bytes32 documentHash);\n    event EmployeeRegistered(address indexed employee);\n\n    constructor(ConstructorArgumentsOrganizations[] memory _orgs, address _fluenceBackendAddress){\n        \n        fluenceBackendAddress = _fluenceBackendAddress;\n        \n        for (uint256 i = 0; i < _orgs.length; i++) {\n            organizations[_orgs[i].orgWalletAddress] = Organization({\n                orgName: _orgs[i].orgName,\n                orgWebsite: _orgs[i].orgWebsite,\n                physicalAddress: _orgs[i].physicalAddress,\n                orgWalletAddress: _orgs[i].orgWalletAddress,\n                isTrusted: true,\n                isFromConstructor: true\n            });\n            \n            emit OrganizationAdded(_orgs[i].orgWalletAddress, _orgs[i].orgName);\n            emit OrganizationTrusted(_orgs[i].orgWalletAddress);\n        }\n        owner = msg.sender;\n    }\n\n    function addOrganization(ConstructorArgumentsOrganizations memory _org) public {\n        require(\n            msg.sender == owner || organizations[msg.sender].isTrusted, \n            \"Not authorized\"\n        );\n        require(\n            organizations[_org.orgWalletAddress].orgWalletAddress == address(0), \n            \"Organization already exists\"\n        );\n\n        organizations[_org.orgWalletAddress] = Organization({\n            orgName: _org.orgName,\n            orgWebsite: _org.orgWebsite,\n            physicalAddress: _org.physicalAddress,\n            orgWalletAddress: _org.orgWalletAddress,\n            isTrusted: false,\n            isFromConstructor: false\n        });\n\n        pendingOrgs.push(_org.orgWalletAddress);\n        emit OrganizationAdded(_org.orgWalletAddress, _org.orgName);\n    }\n\n    function verifyOrganization(address _orgAddress) public {\n        require(organizations[msg.sender].isTrusted, \"Only trusted organizations can verify\");\n        require(!organizations[_orgAddress].isTrusted, \"Organization already trusted\");\n        require(organizations[_orgAddress].orgWalletAddress != address(0), \"Organization does not exist\");\n        require(!verificationStatuses[_orgAddress].companyToValidOrNot[msg.sender], \"Already verified by this organization\");\n\n        verificationStatuses[_orgAddress].companyToValidOrNot[msg.sender] = true;\n        verificationStatuses[_orgAddress].count++;\n\n        emit OrganizationVerified(_orgAddress, msg.sender);\n\n        // Check if verification threshold is met\n        if (verificationStatuses[_orgAddress].count >= VERIFICATION_THRESHOLD) {\n            organizations[_orgAddress].isTrusted = true;\n            emit OrganizationTrusted(_orgAddress);\n            \n            // Remove from pending\n            _removePendingOrg(_orgAddress);\n        }\n    }\n\n    function registerEmployee(address _employee) public onlyFluenceBackend{\n        registeredEmployees[_employee] = true;\n        emit EmployeeRegistered(_employee);\n    }\n\n    function getUserDocuments(address _user) public view returns (DocumentRecord[] memory) {\n        return userDocuments[_user];\n    }\n\n    function addDocument(address _user, bytes32 _documentHash) public {\n        require(organizations[msg.sender].isTrusted, \"Only trusted organizations can add documents\");\n        require(registeredEmployees[_user], \"Employee not registered\");\n\n        userDocuments[_user].push(DocumentRecord({\n            documentHash: _documentHash,\n            addedBy: msg.sender,\n            timestamp: block.timestamp\n        }));\n\n        emit DocumentAdded(_user, msg.sender, _documentHash);\n    }\n\n    function getPendingOrganizations() public view returns (address[] memory) {\n        return pendingOrgs;\n    }\n\n    function getVerificationCount(address _orgAddress) public view returns (uint256) {\n        return verificationStatuses[_orgAddress].count;\n    }\n\n    function hasVerified(address _orgAddress, address _verifier) public view returns (bool) {\n        return verificationStatuses[_orgAddress].companyToValidOrNot[_verifier];\n    }\n\n    function _removePendingOrg(address _orgAddress) private {\n        for (uint256 i = 0; i < pendingOrgs.length; i++) {\n            if (pendingOrgs[i] == _orgAddress) {\n                pendingOrgs[i] = pendingOrgs[pendingOrgs.length - 1];\n                pendingOrgs.pop();\n                break;\n            }\n        }\n    }\n\n    function checkIfEmployeeExists(address _employee) public view returns (bool) {\n        return registeredEmployees[_employee];\n    }\n\n    function checkIfOrgExists(address _orgAddress) public view returns (bool) {\n        return organizations[_orgAddress].orgWalletAddress != address(0);\n    }\n\n    // Emergency functions for owner\n    function removeOrganization(address _orgAddress) public onlyOwner {\n        require(!organizations[_orgAddress].isFromConstructor, \"Cannot remove constructor organizations\");\n        delete organizations[_orgAddress];\n        _removePendingOrg(_orgAddress);\n    }\n\n    function setVerificationThreshold(uint256 _newThreshold) public onlyOwner {\n        // Note: This would require updating the constant to a state variable\n        // VERIFICATION_THRESHOLD = _newThreshold;\n    }\n}"
      }
    }
  }
}